import { ArticleLayout } from '@/components/ArticleLayout'
import Image from 'next/image'
import timeTracker from "./timeTracker.png"
import positionGenerator from "./positionGenerator.png"
import newPages from "./newPages.png"
import invoicesOverview from "./invoicesOverview.png"
import filter from "./filter.png"
import quickViewAndDownload from "./quickViewAndDownload.png"
import paymentReminder from "./paymentReminder.png"
import paymentReminderButton from "./paymentReminderButton.png"
import paymentReminderDocument from "./paymentReminderDocument.png"
import positionOrder from "./positionOrder.png"
import customerSettings from "./customerSettings.png"

export const meta = {
  author: 'Fabian Wassermann',
  date: '2024-12-11',
  title: '√úbersicht der letzten 14 Monate',
  description:
    'Ein Jahr Bug-Fixes und eine Menge neuer Funktionen sp√§ter. Dies ist eine √úbersicht der letzten 14 Monate bez√ºglich dieses Projekts.',
}

export default (props) => <ArticleLayout meta={meta} {...props} />

## Statistiken

<div className="flex items-center gap-2">
  In den letzten 14 Monaten habe ich **64 Stunden und 30 Minuten** an diesem Projekt gearbeitet. 
  Das ist nicht viel, aber genug f√ºr einige coole neue Sachen.
  <Image src={timeTracker} alt="" />
</div>

Nach **197 Commits**, **69 Pull Requests** und **82 geschlossenen Issues** bin ich stolz darauf, Ihnen eine gro√üartige √úbersicht aller neuen Funktionen zu zeigen.

## Neue Funktionen

In den folgenden Abschnitten werde ich die neuen Funktionen der Software beschreiben. Funktionen wie **Text nach Tabelle**, **Redesign von Dokumenten** und **hilfreiche UI-Erg√§nzungen**, um nur einige zu nennen, haben es nicht in die folgende Funktionsliste geschafft, da sie zu klein sind, um sie zu erw√§hnen.

### Funktion 1: Dokument√ºbersichtsseiten

<Image src={newPages} alt="" />

Die Navigation wurde gr√∂√üer. Jetzt gibt es √úbersichtsseiten f√ºr **Rechnungen**, **Angebote** und **Lieferscheine**.
Das folgende Bild zeigt die Rechnungs√ºbersichtsseite, ich musste einige Teile zensieren. Die anderen √úbersichtsseiten sind fast gleich, aber mit verschiedenen Status.

<Image src={invoicesOverview} alt="" />

### Funktion 2: Dokumentstatus

Dokumente haben jetzt Status. Hier ist eine Liste aller Status:

- **Rechnungen:** bezahlt / nicht bezahlt
- **Rechnungen:** gesendet / nicht gesendet
- **Angebote:** in Rechnung umgewandelt / nicht in Rechnung umgewandelt
- **Lieferscheine:** in Rechnung umgewandelt / nicht in Rechnung umgewandelt

### Funktion 3: Filter auf der Rechnungs√ºbersichtsseite

<Image src={filter} alt="" />

Rechnungen k√∂nnen nach Datumsbereichen oder nach Zahlungsstatus gefiltert werden.

### Funktion 4: Schnellansicht und Download

<Image src={quickViewAndDownload} alt="" />

Durch Klicken auf das Auge √∂ffnet sich ein neuer Tab, der das Dokument anzeigt. Der Download-Button ist, denke ich, leicht zu verstehen.

### Funktion 5: Zahlungsdaten verfolgen

<Image src={paymentReminder} alt="" />

Wenn eine Rechnung an den Kunden gesendet wurde, aber nicht bezahlt ist, verfolgt die App die Tage zwischen dem Senden und dem Erhalten der Zahlung.
Wenn die Rechnung nach 30 Tagen vom Kunden nicht bezahlt wurde, wird eine kleine Uhr sichtbar und beim Dar√ºberfahren zeigt ein Tooltip
an, wie viele Tage die Rechnung nicht bezahlt wurde.

Es gibt ein zweites rotes Ausrufezeichen-Symbol. Dieses wird angezeigt, wenn die Rechnung l√§nger als 6 Wochen nicht bezahlt wurde.

### Funktion 6: Zahlungserinnerungen generieren

<Image src={paymentReminderButton} alt="" />

Wenn der Kunde die Rechnung nicht bezahlt hat und das F√§lligkeitsdatum √ºberschritten hat, wird eine neue Aktion im Mehr-Men√º verf√ºgbar - Zahlungserinnerung generieren.
Durch Klicken auf diesen Button wird ein fertiges Zahlungserinnerungsdokument generiert, das wie folgt aussieht.

<Image src={paymentReminderDocument} alt="" />

### Funktion 7: Positionsreihenfolge √§ndern

<Image src={positionOrder} alt="" />

Durch Klicken auf den Pfeil-Button werden die beiden Positionen den Platz tauschen. Mit dieser Funktion kann der Benutzer die Positionsreihenfolge eines Dokuments modifizieren.

### Funktion 8: Standardeinstellungen f√ºr Kunden

<Image src={customerSettings} alt="" />

Jeder Kunde kann verschiedene Standardeinstellungen haben.
Kunden k√∂nnen einen festen Arbeitszeitrabatt oder einen festen Rabatt f√ºr Teile erhalten. Diese Seite ist daf√ºr gedacht, das Leben zu erleichtern, wenn man mit vielen Kunden arbeitet.

## Bugs üêõ

Schauen wir uns die Bugs an. 
Weil Bugs in jeder Software sind und ich m√∂chte einige Bugs diskutieren, die ich nach der ersten Ver√∂ffentlichung der Software behoben habe.

### Bug 1 - Positionsgenerator Tastaturnavigation

<Image src={positionGenerator} alt="" />

Wenn Sie mehr als ein paar Positionen zu einer Rechnung eingeben m√ºssen, m√∂chten Sie sicherlich eine ordentliche Tastaturnavigation f√ºr diese Eingaben haben.

Anfangs sollte der Cursor-Fokus auf der ersten Eingabe (Artikelnummer-Eingabe) liegen. 
Beim Klicken auf **Enter** in der ersten Eingabe sollte der Suchbutton ausgel√∂st werden,
der automatisch einige Daten in die n√§chsten Felder rechts ausf√ºllt. Dr√ºcken von **Tab** sollte den 
Cursor-Fokus von der ersten Eingabe Schritt f√ºr Schritt zur letzten Eingabe bewegen. W√§hrend der Cursor-Fokus auf einer dieser Eingaben liegt,
sollte Dr√ºcken von **Enter** den Button auf der linken Seite (Erstellen-Button) ausl√∂sen.

Das HTML, CSS und JS, das ich codiert habe, respektierte dieses Verhalten nicht, aber ich werde Ihnen jetzt zeigen, wie ich es behoben habe.

```ts
<input
  @keyup.enter="createPosition"
/>
```

Dies ist der Event-Listener, der auf allen Eingaben au√üer der ersten liegt. Wenn die **Enter**-Taste in einer dieser Eingaben gedr√ºckt wird, wird die Position erstellt. F√ºr die erste Eingabe habe ich *createPosition* 
durch die *searchAndFillData* Funktion ersetzt.

```ts
function createPosition() {
  ...
  articleNumberInputRef.value.focus();
  ...
}
```

Nach der Positionserstellung wird die neue Artikelnummer-Eingabe durch Code fokussiert. 
Dieses Verhalten erm√∂glicht es dem Benutzer, viele Positionen nur mit der Tastatur einzugeben.

### Bug 2 - Datenbankmodell eindeutige Nummer von Dokumenten

Jedes Dokument hat seine eigene eindeutige Nummer. F√ºr Rechnungen zum Beispiel haben die Nummern das folgende Format: **nummer/yyyy**.
Die erste Rechnung des n√§chsten Jahres w√§re **001/2025** und die zweite Rechnung **002/2025**. Um diese Gesch√§ftslogik zu gew√§hrleisten, habe ich 
eine eindeutige Einschr√§nkung f√ºr das Nummernfeld im Datenbankmodell hinzugef√ºgt.

```ts
number String @unique
```

Wenn der Benutzer eine Rechnung l√∂scht, die wichtig war, w√§re sie f√ºr immer weg. Um zu verhindern, dass der Benutzer wichtige 
Dokumente l√∂scht, wurde ein **isDeleted** Flag zum Datenbankmodell hinzugef√ºgt. Wenn der Benutzer versucht, eine Rechnung zu l√∂schen, wird der Backend
die Rechnung nicht l√∂schen, sondern das **isDeleted** Flag auf den aktuellen Zeitstempel setzen. Die Rechnung ist jetzt archiviert, aber nicht endg√ºltig gel√∂scht.

Wenn der Benutzer eine neue Rechnung erstellen m√∂chte, sollte die Nummer der archivierten Rechnung zur Verwendung frei sein. Aber das Speichern einer anderen Rechnung mit 
derselben Nummer w√ºrde die eindeutige Einschr√§nkung verletzen.

In den meisten relationalen Datenbanken sind diese Verhaltensweisen einfach zu implementieren, aber mit PrismaORM und MongoDB kann das noch nicht gemacht werden.
Ich habe mich gewundert, wie ein gro√üer ORM wie Prisma nichts daf√ºr hat, dies zu handhaben, und ich habe ein offenes [Issue](https://github.com/prisma/prisma/issues/6974) gefunden, das jetzt fast 4 Jahre alt ist.

Ich habe schlie√ülich die eindeutige Einschr√§nkung entfernt. Dieser Teil der Gesch√§ftslogik muss jetzt vom Backend gehandhabt werden.

```ts
number String
```

### Bug 3 - Arbeitszeitrabatt richtig berechnen

```js
worktimeDiscount =
      (worktimeTotal * worktimeDiscountPercentage) / 100;
```

Um es klar zu machen, eine einfache Arbeitszeitrabattberechnung ist einfach und das ist nicht der Fehler, den ich gemacht habe.
Ich habe den Rabatt nur auf die erste Arbeitszeitposition angewendet und nicht auf jede. Das ist eine einfache Behebung mit einer grundlegenden for-Schleife.


Vielen Dank f√ºr das Lesen dieses Software-Updates!
